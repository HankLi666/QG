## 1.自定义异常处理

### 1.定义异常处理类

```python
class StockError(Exception):
    """用于处理库存相关的逻辑错误"""
    pass
```

- Python 要求所有自定义异常必须直接或间接继承自内置的 `BaseException`（通常选 `Exception`）

- **`pass`**：因为 `Exception` 基类已经处理好了所有核心逻辑（比如存储报错信息），所以不需要写任何代码，只需声明这个类型存在即可

### 2.抛出异常

```python
raise StockError(f"库存不足！'{self.name}' 仅剩 {self.__stockcnt} 本。")
```

- **`raise`**：这是一个**主动中断**指令
  - 一旦执行这行，代码会立即停止向下运行，开始向外寻找 `except` 块
- **`StockError(...)`**：
  - 这实际上是在**实例化**刚才定义的异常处理类
  - 传入的 `f-string` 字符串会被存入异常对象的内部属性

### 3.获取并处理异常

```python
except StockError as e:
    print(f"捕获到异常: {e}")
```

- **`except StockError`**：
  - 这是“安检哨点”。它告诉 Python：如果 `try` 块里抛出的是 `StockError` 类型（或者它的子类），就归我管。
  - 如果抛出的是其他异常（比如 `ZeroDivisionError`），这个哨点就会放行，程序会继续向外层崩塌。
- **`as e`**：
  - 这是一个**赋值**操作,把刚才 `raise` 出来的那个具体的异常实例，起个别名叫 `e`
- **`print(f"捕获到异常: {e}")`**：
  - 直接打印对象 `e` 时，Python 会自动调用该对象的 `__str__` 方法,
  - 它会把在 `raise` 时填进去的那句“库存不足...”原封不动地打印出来

---

## 2.继承中类变量的动态绑定

```python
class Books:
    __total = 0
    def __init__(self):
        Books.__total += 1 # 永远修改父类的变量
```

- **后果**：无论创建 `Science` 还是 `Literature`，数据全都会堆在 `Books._total` 里，无法分门别类统计。

####  `self.__class__`

```python
class Books:
    __total = 0	
    def __init__(self):
        self.__class__.__total += 1 # 谁诞生，就改谁的变量
```

 	**子类中需要重新定义该类变量**

- **效果**：如果实例是 `Science` 类型，它就去改 `Science._total`；如果是 `Literature`，就改 `Literature._total`。

---

## 3.Bug 记录：消失的返回值与 None

- **现象**：调用 `print(obj.func())` 时，终端输出了 `None`。

- **原因**：Python 函数若无 `return` 语句，默认返回 `None`。在函数内部使用了 `print` 仅仅是向屏幕输出，并没有将数据传递给调用者

  **【文档细节：关于 f-string 中的嵌套调用】** 查阅文档确认，`f"{func()}"` 会捕获 `func` 的返回值。如果 `func` 负责打印而不返回，就会产生重复输出和 `None` 的冗余

- **解决措施**：将返回值改为`f"..."`，再调用 `print(obj.func())`，即可打印出`""`内的文本

  ```python
  def get_class_cnt(self):
          return f"共有{self.__class__.__class_totalcnt}本,在库   
          {self.__class__.__class_stockcnt}本"
          
  print(f"科学类在库总量: {p1.get_class_cnt()}")  
  ```


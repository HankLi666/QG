## 一、面向对象的概念

面向对象编程（OOP）是一种将**数据**（属性）和**操作数据的代码**（方法）打包在一起的设计思想。
- **面向过程（C语言）**：关注函数的执行步骤，数据结构（`struct`）和函数是分离的，可理解为
  `编年体`

- **面向对象**：关注“对象”本身。对象是类的实例，它知道自己是谁（属性），也知道自己能做什么（方法），可理解为`纪传体`


---

## 二、类 (Class) 与实例化 (Instantiation)
类是对象的一个抽象概念，由属性与方法构成
### 1. 属性
在 C 语言中，声明这样一个结构体来存放数据：
```c
struct Player {
    char name[20];
    int level;
    int health;
};
```
而在面向对象编程中 `name`、`level`、`health` 就被称为类的**属性（Attribute）**
#### 实例属性 (Instance Attribute) —— 对应 C 的成员变量

- **定义方式**：通常在 `__init__` 方法中，必须带 `self.` 前缀。
```python
class Player:
    def __init__(self, a, b, c):
        self.name = a    
        self.level = b
        self.health = c
```

#### 类属性 (Class Attribute) —— 对应 C 的 `static` 变量
  
- **定义**：在类体内、方法外定义（一般在类下方第一行）

- **特点**：**所有实例共享**同一份数据。修改类变量会影响所有对象（除非实例覆盖了它）。

- **应用场景**：比如“当前机器人总数”。不需要在每个 `Robot` 结构体里都存一遍总数，而是全类公用一个计数器。
```python
class Robot:
    population = 0  # 类属性：记录机器人总数
    def __init__(self, name):
        self.name = name  # 实例属性：每个机器人的名字
        Robot.population += 1 # 访问类属性

r1 = Robot("R2D2")
r2 = Robot("C3PO")
print(Robot.population) # 输出：2
```
### 2. 方法

在 C 语言中，操作数据的函数通常是这样定义的：

```c
// C 语言需要手动传入结构体指针
void attack(struct Player *p, int damage) {
    p->health -= damage;
}
```

而在面向对象编程中，这种操作数据的函数被称为**方法（Method）**。

#### 实例方法 (Instance Method) —— 对应 C 的“以结构体指针为首参数的函数”

- **定义方式**：第一个参数必须是 `self`。

- **调用本质**：当你调用 `p1.attack(10)` 时，Python 自动将其转化为 `Player.attack(p1, 10)`。`self` 自动接收了实例的地址。
```python
class Player:
    def __init__(self, name, health):
        self.name = name
        self.health = health

    def attack(self, damage): # 实例方法
        self.health -= damage
        print(f"{self.name} 受到了攻击，剩余生命：{self.health}")
```

#### 类方法 (Class Method) —— 对应 C 的“全局管理函数”

- **定义方式**：使用 `@classmethod` 装饰器，第一个参数固定为 `cls`（代表类本身）。

- **特点**：它不关注具体的某个实例（`self`），而是关注整个类。常用于修改类属性或实现“工厂模式”。

```python
class Robot:
    population = 0
    #类方法
    def get_total_robots(cls): # cls 就像是 Robot 类的别名
        return f"当前存活机器人总数：{cls.population}"
```
### 3. 实例化
在 C 语言中，实例化一个结构体通常分为两步：
1. **分配内存**

2. **手动初始化**
```c
struct Player {
    char name[20];
    int level;
    int health;
};
struct Player* p = (struct Player*)malloc(sizeof(struct Player));
strcpy(p->name,"张三”)；
p -> level = 2;
p -> health = 100;
```
在 Python 中，直接像调用函数一样调用类名
```python
class Player:
    def __init__(self, a, b, c):
        self.name = a    
        self.level = b
        self.health = c
p = Player('张三' , 2 , 100)
```
### 4. `self` 的本质

`self` 是 Python 自动传给方法的第一个参数，它指向**当前实例对象**。

- **语法**：虽然在定义方法时必须写 `self`，但在调用时**不需要**手动传它

```python
class Player:
    def __init__(self, nickname): # 构造实例属性
        self.nickname = nickname # 绑定属性到 self

# 实例化：创建两个不同的对象
p1 = Player("剑圣")
p2 = Player("法神")
```
---
## 三、私有属性与私有方法
在 Python 中，通过在名称前增加**双下划线 `__`** 来实现私有化。

#### 私有变量  —— 对应 C 的“非公开结构体成员”

- **定义方式**：在 `__init__` 或类中，使用 `self.__变量名`。

```python
class BankAccount:
    def __init__(self, money):
        self.__balance = money  # 私有属性：外部无法通过 对象名.__balance 访问

    def get_balance(self):
        # 内部可以访问，通过公开接口（Getter）返回数据
        return self.__balance
```

#### 私有方法—— 对应 C 的 `static` 函数

- **定义方式**：在方法名前加 `__`。
```python
class Phone:
    def __init__(self, psw):
        self.__password = psw

    def __encrypt_data(self):  # 私有方法：加密逻辑
        print("正在进行底层加密计算...")

    def send_message(self, text):
        self.__encrypt_data()  # 内部调用合法
        print(f"信息已发出：{text}")

p = Phone("123")
# p.__encrypt_data()  # 报错：外部不可访问
p.send_message("你好") # 正确：外部只需关注功能，不关注底层加密过程
```

---
## 四、 面向对象三大特性

### 1. 封装 (Encapsulation)

**封装**其实就是将上面提到的“属性”和“方法”有机地结合在一起，并通过“私有化”设定访问边界。

- **核心思想**：隐藏对象的属性和实现细节，仅对外公开接口。

### 2. 继承 (Inheritance)

在 C 语言中，如果想让 `Student` 结构体拥有 `Person` 的特性，需要手动嵌套：

```c
struct Person {
    char name[20];
};
struct Student {
    struct Person base; // 嵌套
    int score;
};
```

在 Python 中，继承让这种关系变得更原生。

- **定义方式**：`class 子类(父类):`

- **`super()` 关键字**：用于调用父类的方法（尤其是构造方法）。
```python
class Person:
    def __init__(self, name):
        self.name = name
    def walk(self):
        print(f"{self.name} 正在走路")

class Student(Person): # 继承 Person
    def __init__(self, name, score):
        super().__init__(name) # 自动调用父类初始化
        self.score = score
```
### 3. 多态 (Polymorphism)
**核心概念**：不同的子类对象调用同一个方法名，产生不同的执行结果。

```python
class Dog:
    def speak(self): print("汪汪汪")

class Cat:
    def speak(self): print("喵喵喵")

def make_sound(animal): # 统一接口
    animal.speak()     # 传入狗就汪，传入猫就喵

make_sound(Dog())      # 汪汪汪
make_sound(Cat())      # 喵喵喵
```